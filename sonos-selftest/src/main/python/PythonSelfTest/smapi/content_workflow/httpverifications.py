import selftestinit #ignore @UnusedImport for packaging
import sys
import urllib2
from sonos.workflow.fixture import WorkflowTestFixture
from sonos.workflow.basicsuite import BasicWorkflowTestSuite
from sonos.smapi.smapiservice import SMAPIService, TRACKMETADATA, STREAMMETADATA, MEDIAMETADATA, ALBUMARTURI, LOGO, USERID
from sonos.smapi.smapiclient import SMAPIClient, CR_STANDARD_RANGE, SECONDS_BETWEEN_RETRY, HTTP_CODE_RECOVERABLE
from utility import ServiceConfigOptionParser,DynamicTestContent
from time import sleep
from sonos.smapi.smapiexceptions import ItemNotFound, ServiceUnavailable, SonosError

class HTTPBasedTests(WorkflowTestFixture, SMAPIClient, SMAPIService):
    """
    This class holds the tests that will check the service's implementation of byte range seeking. These tests
    will ask for only pieces of a mediaURI for the test track supplied in the config file.
    """

    def __init__(self, client, smapiservice):
        super(HTTPBasedTests,self).__init__()
        self.client = client
        self.smapiservice = smapiservice
        self.played_seconds = 10

    def initialize(self):
        pass

    def test_byte_range_seeking_no_end_specified(self):
        """
        This test will request bytes 500-end of a mediaURI that has been generated from the sample trackID provided in the
        config file.
        Expected result: HTTP 206 response from server (Partial content response)
        """
        self.verifyTrueOrSkip(self.smapiservice.get_test_track_id(), "Service must provide a valid track ID ([Test "
                                                                     "Content]:track in the config file) for this "
                                                                     "test to run.")
        try:
            media_uri = self.client.getMediaURI(self.smapiservice.get_test_track_id(), self)
            if type(media_uri) is SonosError:
                sonos_error_code = media_uri.webfault.fault.detail.SonosError
                self.verifyIsNotNoneOrFailCase(sonos_error_code, "A SonosError should contain a SonosError code "
                                                                 "inside.")
        except (ItemNotFound, ServiceUnavailable) as e:
            additional_message = "Trying to update test content now." if type(e) is ItemNotFound \
                else "The service is currently unavailable."
            self.console_logger.warn("Received an {0} exception in response to getMediaURI for the test "
                                     "track in the partner config. {1}".format(type(e).__name__), additional_message)
            if type(e) is ItemNotFound:
                DynamicTestContent.update_test_track(self)
                media_uri = self.client.getMediaURI(self.smapiservice.get_test_track_id(), self)

        self.verifyIsNotNoneOrStop(media_uri,"getMediaURI should return something other than None.")
        self.verifyInOrStop('getMediaURIResult', media_uri, "getMediaURI should return a getMediaURIResult.")
        if self.smapiservice.get_support_playbacklogging() == True:
            set_played_seconds_response = self.client.setPlayedSeconds(self.smapiservice.get_test_track_id(),
                                                                       self.played_seconds, self)
            self.verifyIsNoneOrFailCase(set_played_seconds_response, "setPlayedSeconds should return None.")

        request = urllib2.Request(media_uri.getMediaURIResult)
        if hasattr(media_uri, 'httpHeaders'):
            count = 0
            size = len(media_uri.httpHeaders.httpHeader)
            while size > count:
                request.add_header(media_uri.httpHeaders.httpHeader[count].header, media_uri.httpHeaders.httpHeader[count].value)
                count += 1

        request.add_header("Range", "bytes=500-")

        try:
            response = self.__open_url(request)
            self.verifyEqualOrFailCase(206, response.getcode(), "A request for partial should return an HTTP 206 "
                                                                "status. The URI requested was ({0})."
                                       .format(request.get_full_url()))
            response.close()
        except urllib2.HTTPError, e:
            self.fail("Attempting to open a partial content URI ({0}) returned an HTTP {1} code"
                      .format(request.get_full_url(), e.code))
        except urllib2.URLError, e:
            self.warn("Attempting to open a partial content URI ({0}) returned an error: {1}."
                      .format(request.get_full_url(), e))

    def test_byte_range_seeking_beginning_and_end_specified(self):
        """
        This test requests a block of content from a mediaURI that has been generated by the sample trackID provided in the
        config file. The requested byte range should be returned in response headers.
        Expected result: Response headers should include the requested range.
        """
        self.verifyTrueOrSkip(self.smapiservice.get_test_track_id(), "Service must provide a valid track ID ([Test "
                                                                    "Content]:track in the config file) for this "
                                                                    "test to run.")
        try:
            media_uri = self.client.getMediaURI(self.smapiservice.get_test_track_id(), self)
            if type(media_uri) is SonosError:
                sonos_error_code = media_uri.webfault.fault.detail.SonosError
                self.verifyIsNotNoneOrFailCase(sonos_error_code, "A SonosError should contain a SonosError code "
                                                              "inside.")
        except (ItemNotFound, ServiceUnavailable) as e:
            additional_message = "Trying to update test content now." if type(e) is ItemNotFound \
                else "The service is currently unavailable."
            self.console_logger.warn("Received an {0} exception in response to getMediaURI for the test "
                                     "track in the partner config. {1}".format(type(e).__name__), additional_message)

            if type(e) is ItemNotFound:
                DynamicTestContent.update_test_track(self)
                media_uri = self.client.getMediaURI(self.smapiservice.get_test_track_id(), self)
        self.verifyIsNotNoneOrStop(media_uri,"getMediaURI should return something other than None.")
        self.verifyInOrStop('getMediaURIResult', media_uri, "getMediaURI should return a getMediaURIResult.")
        if self.smapiservice.get_support_playbacklogging():
            set_played_seconds_response = self.client.setPlayedSeconds(self.smapiservice.get_test_track_id(),
                                                                       self.played_seconds, self)
            self.verifyIsNoneOrFailCase(set_played_seconds_response, "setPlayedSeconds should return None.")

        range_request = "bytes=0-300"
        range_response = "bytes 0-300"

        request = urllib2.Request(media_uri.getMediaURIResult)
        if hasattr(media_uri, 'httpHeaders'):
            count = 0
            size = len(media_uri.httpHeaders.httpHeader)
            while size > count:
                request.add_header(media_uri.httpHeaders.httpHeader[count].header, media_uri.httpHeaders.httpHeader[count].value)
                count += 1

        request.add_header("Range", range_request)

        try:
            response = self.__open_url(request)
            response_headers = response.info().getheader("Content-Range")
            self.verifyNotEqualOrStop(None, response_headers, "\"Content-Range\" should be defined in a partial "
                                                              "response's header")
            self.verifyInOrFailCase(range_response, response_headers, "The \"Content-Range\" header should contain the "
                                                                      "requested byte range (\"{0}\")."
                                    .format(range_response))
            response.close()
        except urllib2.HTTPError, e:
            self.fail("A request for partial content should not return an HTTP error code of {0}. The URI requested  "
                      "was ({1}).".format(e.code, request.get_full_url()))
        except urllib2.URLError, e:
            self.warn("A request for partial content returned a URI Error {1}. The URI requested was ({1})."
                      .format(e, request.get_full_url()))

    def test_albumart_uri_valid(self):
        """
        This test checks that the albumart returned by the service is alive and accessible.
        """
        self.verifyTrueOrSkip(self.smapiservice.get_test_track_id(), "Service must provide a valid track ID ([Test "
                                                                     "Content]:track in the config file) for this "
                                                                     "test to run.")
        self.verifyTrueOrSkip(self.client.strict, "Service must have strict validation set to \"True\" "
                                                  "([Validation Settings]:strict in the config file) for this test to "
                                                  "run.")
        track_id = self.smapiservice.get_test_track_id()

        the_metadata = self.client.getMediaMetadata(track_id, self)
        self.verifyIsNotNoneOrStop(the_metadata, "getMediaMetadata should return something other than None.")
        if TRACKMETADATA in the_metadata:
            self.verifyInOrStop(ALBUMARTURI, the_metadata.trackMetadata, "trackMetadata should contain an albumArtURI "
                                                                         "inside. getMediaMetadata was called on ID = "
                                                                         "{0}.".format(track_id))
            if hasattr(the_metadata.trackMetadata.albumArtURI,'value'):
                ALBUMARTURI_string = the_metadata.trackMetadata.albumArtURI.value
            else:
                ALBUMARTURI_string = the_metadata.trackMetadata.albumArtURI
            request = urllib2.Request(ALBUMARTURI_string)
        elif MEDIAMETADATA in the_metadata:
            self.verifyInOrStop(TRACKMETADATA,the_metadata.mediaMetadata, "mediaMetadata should contain trackMetadata "
                                                                          "inside. getMediaMetadata was called on "
                                                                          "ID = {0}"
                                .format(track_id))
            self.verifyInOrStop(ALBUMARTURI,the_metadata.mediaMetadata.trackMetadata, "trackMetadata should contain an "
                                                                                      "albumArtURI inside. "
                                                                                      "getMediaMetadata was called on "
                                                                                      "ID = {0}.".format((track_id)))
            if hasattr(the_metadata.mediaMetadata.trackMetadata.albumArtURI,'value'):
                ALBUMARTURI_string = the_metadata.mediaMetadata.trackMetadata.albumArtURI.value
            else:
                ALBUMARTURI_string = the_metadata.mediaMetadata.trackMetadata.albumArtURI
            request = urllib2.Request(ALBUMARTURI_string)
        else:
            self.stop('trackMetadata or mediaMetadata should be found in getMediaMetadataResponse.')

        try:
            response = self.__open_url(request)
            self.verifyEqualOrFailCase(200, response.getcode(), "Attempting to open a discovered albumArtURI ({0}) "
                                                                "should return an HTTP 200 status.".format(request))
            response.close()
        except urllib2.HTTPError, e:
            self.fail("A request for partial content should not return an HTTP error code of {0}. The URI requested  "
                      "was ({1}).".format(e.code, request.get_full_url()))
        except urllib2.URLError, e:
            self.warn("A request for partial content returned a URI Error {1}. The URI requested was ({1})."
                      .format(e, request.get_full_url()))

    def test_artprog_uri_valid(self):
        """
        This test checks that the albumart returned for a program by the service is alive and accessible.
        """
        self.verifyTrueOrSkip(self.smapiservice.get_test_prog_id(), "Service must provide a valid program ID ([Test "
                                                                    "Content]:program in the config file) for this "
                                                                    "test to run.")
        self.verifyTrueOrSkip(self.client.strict, "Service must have strict validation set to \"True\" "
                                                  "([Validation Settings]:strict in the config file) for this test to "
                                                  "run.")
        prog_id = self.smapiservice.get_test_prog_id()

        (prog_metadata,warning) = self.client.getMetadata(prog_id, CR_STANDARD_RANGE.index, CR_STANDARD_RANGE.count,
                                                          self) #ignore @UndefinedVariable for named tuple
        self.verifyIsNotNoneOrStop(prog_metadata,'getMetadata should return something other than None.')
        if warning is not None:
            self.warn("Calling getMetadata(\'{0}\') returned an error: {1}.".format(prog_id, warning))

        self.verifyIsNotNoneOrStop(prog_metadata,'getMetadata should not be empty.')
        self.verifyInOrStop(TRACKMETADATA,prog_metadata.Items[0],'%s should be found in mediaMetadata.' %(TRACKMETADATA))
        self.verifyInOrStop(ALBUMARTURI,prog_metadata.Items[0].trackMetadata,'%s should be found in trackMetadata.' %(ALBUMARTURI))
        if hasattr(prog_metadata.Items[0].trackMetadata.albumArtURI, "value"):
            request = urllib2.Request(prog_metadata.Items[0].trackMetadata.albumArtURI.value)
        else:
            request = urllib2.Request(prog_metadata.Items[0].trackMetadata.albumArtURI)

        try:
            response = self.__open_url(request)
            self.verifyEqualOrFailCase(200, response.getcode(), "Attempting to open a URI {0} should return an HTTP 2"
                                                                "00 status.".format(request.get_full_url()))
            response.close()
        except urllib2.HTTPError, e:
            self.fail("A request for partial content should not return an HTTP error code of {0}. The URI requested  "
                      "was ({1}).".format(e.code, request.get_full_url()))
        except urllib2.URLError, e:
            self.warn("A request for partial content returned a URI Error {1}. The URI requested was ({1})."
                      .format(e, request.get_full_url()))


    def test_artlogo_uri_valid(self):
        """
        This test checks that the albumart returned for a stream is valid and accessible.
        """
        self.verifyTrueOrSkip(self.smapiservice.get_test_stream_id(), "Service must provide a valid stream ID ([Test "
                                                                      "Content]:stream in the config file) for this "
                                                                      "test to run.")
        self.verifyTrueOrSkip(self.client.strict, "Service must have strict validation set to \"True\" "
                                                  "([Validation Settings]:strict in the config file) for this test to "
                                                  "run.")
        stream_id = self.smapiservice.get_test_stream_id()
        stream_metadata = self.client.getMediaMetadata(stream_id, self)

        self.verifyIsNotNoneOrStop(stream_metadata, "getMediaMetadata should return something other than None.")

        self.verifyInOrStop(STREAMMETADATA, stream_metadata, "mediaMetadata should contain streamMetadata "
                                                             "inside. getMediaMetadata was called on ID = {0}."
                            .format(stream_id))
        self.verifyInOrStop(LOGO,stream_metadata.streamMetadata, "streamMetadata should contain a logo inside. "
                                                                 "getMediaMetadata was called on ID = {0}."
                            .format(stream_id))
        request = urllib2.Request(stream_metadata.streamMetadata.logo)

        self.__open_url(request)

        try:
            response = self.__open_url(request)
            self.verifyEqualOrFailCase(200, response.getcode(), "Attempting to open a URI {0} should return an HTTP "
                                                                "200 status.".format(request.get_full_url()))
            response.close()
        except urllib2.HTTPError, e:
            self.fail("A request for partial content should not return an HTTP error code of {0}. The URI requested  "
                      "was ({1}).".format(e.code, request.get_full_url()))
        except urllib2.URLError, e:
            self.warn("A request for partial content should returned a URI Error {1}. The URI requested was ({1})."
                      .format(e, request.get_full_url()))

    def test_implicit_explicit_actions(self):
        """
        This test checks that the implicit/explicit flag works correctly in getMediaURI requests and the service does
        not return any errors or blank responses.
        """
        self.verifyTrueOrSkip(self.smapiservice.get_test_track_id(), "Service must provide a valid track ID ([Test "
                                                                     "Content]:track in the config file) for this "
                                                                     "test to run.")
        self.verifyTrueOrSkip(self.smapiservice.get_support_implicit_explicit(), "Service must support implicit and "
                                                                                 "explicit actions in order for this "
                                                                                 "test to be run.")
        failure_flag = 0
        try:
            test_response = self.client.getMediaURI(self.smapiservice.get_test_track_id(), self, 'IMPLICIT')
            self.verifyIsNotNoneOrStop(test_response,'getMediaURI should not return None.')
        except Exception, e:
            failure_flag = 1
            self.console_logger.warn("Received an exception in response to a getMediaURI request with IMPLICIT action"
                                     " type.")

        try:
            test_response = self.client.getMediaURI(self.smapiservice.get_test_track_id(), self, 'EXPLICIT')
            self.verifyIsNotNoneOrStop(test_response,'getMediaURI should not return None.')
        except Exception, e:
            failure_flag = 1
            self.console_logger.warn("Received an exception in response to a getMediaURI request with EXPLICIT action"
                                     " type.")

        self.verifyFalseOrFailCase(failure_flag, "Received unexpected responses for implicit and/or explicit action "
                                                 "type getMediaURI requests.")

    def __open_url(self, request):
        num_try = self.client.num_try
        while(num_try > 0):
            num_try -= 1
            try:
                response = urllib2.urlopen(request)
                if response.getcode() in HTTP_CODE_RECOVERABLE and num_try > 0:
                    self.warn("Attempting to open a URI ({0}) returned an HTTP status of {1}. {2} retries left. "
                              "Sleeping {3} seconds before next attempt."
                              .format(request.get_full_url(), response.getcode(), num_try, SECONDS_BETWEEN_RETRY))
                    sleep(SECONDS_BETWEEN_RETRY)
                    continue
                else:
                    return response
            except urllib2.HTTPError, e:
                if e.code in HTTP_CODE_RECOVERABLE and num_try > 0:
                    self.warn("Attempting to open a URI ({0}) returned an HTTP error code of {1}. {2} retries left. "
                              "Sleeping {3} seconds before next attempt."
                              .format(request.get_full_url(), e.code, num_try, SECONDS_BETWEEN_RETRY))
                    sleep(SECONDS_BETWEEN_RETRY)
                    continue
                else:
                    raise e

#Main
if __name__ == "__main__":

    parser = ServiceConfigOptionParser(sys.argv)
    suite = BasicWorkflowTestSuite("SMAPI HTTP Validation", args=parser.args)

    suite.smapiservice = SMAPIService(parser.config_file, parser.wsdl, getattr(parser.options, 'content_file'),
                                      suite.logger, suite.console_logger)
    suite.client = suite.smapiservice.buildservice()
    suite.client.login()

    suite.run(HTTPBasedTests(suite.client, suite.smapiservice))